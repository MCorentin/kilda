#!/usr/bin/env python

# Script to compute the KIV2 copy numbers from the ratio of occurrences of curated 
# kmers on the KIV2 and Normalisation region.

# The KIV2 kmers were selected to appear accross the 6 KIV2 copies of the reference genome
# The Normalisation kmers were selected to appear only once on the Normalisation region of the reference genome

# Author = Corentin
# 2024

import getopt, sys, os, warnings

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


global VERSION
VERSION = "1.3.0"


def print_version():
    """Print the version"""
    global VERSION
    print("kilda.py v" + VERSION)


def usage():
    """Print the usage."""
    print("\nkilda.py -c [counts_list.tsv] -k [KIV2_unique_21mer_with_rc.tsv] -l [LPA_unique_21mer_with_rc.tsv] -r [lpa_rsids.tsv] -o [output_folder] -p -v")
    print("\nInput:")
    print("     -c/--counts          File with the list of ids and counts (generated by 'jellyfish dump') files. One id and file per line, tab_delimited (required).")
    print("     -k/--kiv             File listing the curated KIV2 kmers. (required, default = './KIV2_unique_21mer_with_rc.tsv')")
    print("     -l/--lpa             File listing the curated Normalisation kmers. (required, default = './LPA_unique_21mer_with_rc.tsv')")
    print("     -r/--rsids           File listing rsids of interest and their ref and alt kmers. (optionnal, tab-delimited, no header)")
    print("\nOutput:")
    print("     -o/--output          The path to the output folder. (default = './kilda-output/')")
    print("     -p/--plot            If set, will produce a pdf plot of the kmer occurrences for each sample.")
    print("\nOther:")
    print("     -v/--verbose         If set, will print messages to the screen about the analysis progress.")
    print("     -h/--help            Print the usage and help and exit.")
    print("     -V/--version         Print the version and exit.\n")


def parse_arguments():
    """Parse the arguments from the command line.

    Returns:
        A list of variables corresponding to the parsed arguments.

    Raises:
        GetoptError: raise GetoptError if the arguments can not be parsed.
    """
    # Default values for the arguments:
    counts_list_file = None
    kiv_kmers_file = "./KIV2_unique_21mer_with_rc.tsv"
    lpa_kmers_file = "./LPA_unique_21mer_with_rc.tsv"
    rsids_kmers_file = None
    output_folder = "./kilda-output/"
    plot_on = False
    verbose_on = False

    try:
        opts, args = getopt.getopt(sys.argv[1:], "c:k:l:r:o:pvhV", ["counts=", "kiv=", "lpa=", "rsids=", 
                                                                    "output=", "plot", "verbose", 
                                                                    "help", "version"])
    except getopt.GetoptError as err:
        print(str(err))
        usage()
        sys.exit(1)

    for o,a in opts:
        if o in ("-c", "--counts"):
            counts_list_file = str(a)
        elif o in ("-k", "--kiv"):
            kiv_kmers_file = str(a)
        elif o in ("-l", "--lpa"):
            lpa_kmers_file = str(a)
        elif o in ("-r", "--rsids"):
            rsids_kmers_file = str(a)
        elif o in ("-o", "--output"):
            output_folder = str(a)
        elif o in ("-p", "--plot"):
            plot_on = True
        elif o in ("-v", "--verbose"):
            verbose_on = True
        elif o in ("-h", "--help"):
            usage()
            sys.exit(0)
        elif o in ("-V", "--version"):
            print_version()
            sys.exit(0)
        else:
            assert False, "Unhandled option !"

    return counts_list_file, kiv_kmers_file, lpa_kmers_file, rsids_kmers_file, output_folder, plot_on, verbose_on


def check_arguments(counts_list_file, kiv_kmers_file, lpa_kmers_file, rsids_kmers_file, output_folder):
    """Check the validity of the arguments passed by the user. For example if the file exists.

    Args:
        counts_list_file: a string containing the path to the list of sample IDs + kmer counts files.
        kiv_kmers_file: a string containing the path to the file with the curated KIV2 kmers.
        lpa_kmers_file: a string containing the path to the file with the curated Normalisation kmers.
        rsids_kmers_file: a string containing the path to the file with the rsids of interest and their ref and alt kmers.
        output_folder: a string containing the name of the output folder.

    Returns:
        Nothing, exit() if one of the argument is not valid.
    """
    # Checking if counts_list_file is provided and exists:
    if(counts_list_file == None):
        sys.exit("The -c/--counts argument is mandatory ('None' found). Use -h for usage.")
    elif not os.path.isfile(counts_list_file):
        sys.exit("Error for option -c/--counts: '"+str(counts_list_file)+"' is not a file.")

    # Checking if kiv_kmers_file is provided and exists:
    if(kiv_kmers_file == None):
        sys.exit("The -k/--kiv argument is mandatory ('None' found). Use -h for usage.")
    elif not os.path.isfile(kiv_kmers_file):
        sys.exit("Error for option -k/--kiv: '"+str(kiv_kmers_file)+"' is not a file.")

    # Checking if lpa_kmers_file is provided and exists:
    if(lpa_kmers_file == None):
        sys.exit("The -l/--lpa argument is mandatory ('None' found). Use -h for usage.")
    elif not os.path.isfile(lpa_kmers_file):
        sys.exit("Error for option -l/--lpa: '"+str(lpa_kmers_file)+"' is not a file.")

    if(rsids_kmers_file != None):
        if not os.path.isfile(rsids_kmers_file):
            sys.exit("Error for option -r/--rsids: '"+str(rsids_kmers_file)+"' is not a file.")

    # Exit if output folder already exists (to avoid overwriting an already existing analysis):
    if(os.path.isdir(output_folder)):
        sys.exit("\nFolder '" + output_folder + "' already exists, stopping now...\n")


def read_kmer_file(kmer_file):
    """From a file containing the curated list of kmers, creates a pandas DataFrame
       containing the list of kmers.

    Args:
        kmer_file: a string containing the path to the file with the curated kmers

    Returns:
        A pandas DataFrame with the list of kmers
    """
    kmer_df = pd.read_csv(kmer_file, sep = '\t', index_col = False, names = ['kmer'], header = None)

    # Checking if the kmers are all of the same length.
    # Strange, but not critical, so just write a warning to the user:
    kmer_len = len(kmer_df.at[0, 'kmer'])
    if(not(all(len(kmer) == kmer_len for kmer in kmer_df.loc[:,'kmer']))):
        print("Warning ! For '"+kmer_file+"' not all kmers have the same length! Detected length: "+str(kmer_len))

    return kmer_df


def read_rsids_file(rsids_file, verbose_on):
    """From a file containing a list of ref and alt kmers for different snps, 
       creates a pandas DataFrame containing the rsid, ref kmer and alt kmer.

    Args:
        rsids_file: a string containing the path to the file with the curated kmers

    Returns:
        A pandas DataFrame with the rsid, reference kmer and alternative kmer
    """
    rsids_kmers_df = pd.read_csv(rsids_file, sep = '\t', index_col = False, names = ['rsid', 'kmer_ref', 'kmer_alt'], header = None)

    if(rsids_kmers_df.isnull().values.any()):
        sys.exit("Error when reading '"+rsids_file+"': some values are null. Is the format of the file correct? tab-delimited, columns: 'rsid' 'ref_kmer' 'alt_kmer'.\nStopping now...")
    
    if not rsids_kmers_df["rsid"].is_unique:
        sys.exit("Error: ids are not unique in '"+ rsids_file +"'. Stopping now.")
    
    if(verbose_on): print("Identified '"+str(rsids_kmers_df.shape[0])+"' rsids.\n")
    
    return(rsids_kmers_df)
    

def read_counts(counts_file):
    """From a counts file, creates a pandas DataFrame with the content of the file.
    The file must by tab-delimited.

    Args:
        counts_file: a string containing the path to the output file from "jellyfish dump"

    Returns:
        A pandas DataFrame with the content of the counts file (kmer occurrences).
    """
    try:
        counts_df = pd.read_csv(counts_file, sep = '\t', index_col = False, names = ['kmer', 'occurrence'], header = None)
    except FileNotFoundError:
        sys.exit("Error: count file: '"+str(counts_file)+"' not found. Stopping now.")

    # Checking if we have actual values for the occurrence column:
    if(counts_df['occurrence'].isnull().values.any()):
        sys.exit("Error when reading '"+counts_file+"': some kmer occurrences are null. Is the format of the counts file correct? tab-delimited, columns: 'kmer occurrence'.\nStopping now...")

    return counts_df


def get_kmer_CN(kiv_counts, lpa_counts, verbose_on):
    """Compute the KIV2 CN based on the ratio of the mean occurrence of KIV2 kmers vs Normalisation kmers

    Args:
        kiv_counts: A pandas DataFrame with the KIV2 kmer occurrences.
        lpa_counts: A pandas DataFrame with the Normalisation kmer occurrences.
        verbose_on: A boolean indicating if messages must be printed or not

    Returns:
        The CN as a float.
    """
    kiv_mean = kiv_counts['occurrence'].mean()
    lpa_mean = lpa_counts['occurrence'].mean()

    if(verbose_on): print("\tKIV2 mean kmer occurrence:'%.2f'" % kiv_mean)
    if(verbose_on): print("\tNormalisation mean kmer occurrence:'%.2f'" % lpa_mean)

    if(kiv_mean == 0 or lpa_mean == 0):
        sys.exit("Error: the mean occurrence for the KIV2 or Normalisation kmers is 0: cannot get the ratio.")
    # lpa_mean represents the "coverage" on one copy, but we are interested in the copy number on two copies, so *2
    return (kiv_mean / lpa_mean * 2)
    

def plot_occurrences(kiv_counts, lpa_counts, out_filename, sample_id, CN):
    """Plot the distribution of kmer occurrences for the KIV2 and Normalisation kmers

    Args:
        kiv_counts: A pandas DataFrame with the KIV2 kmer occurrences.
        lpa_counts: A pandas DataFrame with the Normalisation  kmer occurrences.
        out_filename: The plot will be written under this filename.
        sample_id: the sample ID (will be displayed in the plot title)
        CN: The KIV2 CN (will be displayed in the plot title)

    Returns:
        Nothing, save the plot in "{output_folder}/{sample_id}_cov.pdf"
    """
    plt.figure()
        
    plt.hist(kiv_counts['occurrence'], bins = 30, alpha = 0.5, label = 'KIV2 kmers', density = True)
    plt.hist(lpa_counts['occurrence'], bins = 60, alpha = 0.5, label = 'Norm kmers', density = True)
    plt.legend(loc = 'upper right')
        
    plt.xlabel('Kmer occurrence')
    plt.ylabel('Kmer frequence')
    plt.title(str(sample_id) + " (CN=" + str("%.2f" % CN) + ")")
    
    plt.xlim(0, max(kiv_counts['occurrence']))
    
    plt.savefig(fname = str(out_filename))
    plt.close()


def rc(seq):
    """
    Returns the reverse complement of "seq". 
    Function written to avoid having Biopython as a dependency just for "reverse_complement()".
    
    Args:
        seq: a string with the sequence
        
    Returns: 
        A string with the reverse complement of "seq" (non "ATCG" bases are returned as is)
    """
    comp_dict = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}
    # get(base, base) double base used to return the original value, if "base" is not found in the keys of "complement" (non-ATCG characters).
    return("".join(comp_dict.get(base, base) for base in reversed(seq)))

    
def process_rsid(counts_df, rsid, kmer_ref, kmer_alt):
    """
    Counts the occurrences of "kmer_ref" and "kmer_alt" in "counts_df".
    This is used to assess the presence of a rsid in the sample based on kmer counts.
    
    Args:
        counts_df: A pandas DataFrame with the kmer occurrences for one sample.
        rsid: a string with the 'rsid'.
        kmer_ref: the kmer representing the reference allele of the rsid.
        kmer_alt: the kmer representing the alternative allele of the rsid.
        
    Returns:
        The counts of reference kmers and the counts of alternative kmers ("NA") if kmer not found in counts_df.
    """
    if(len(kmer_ref) != len(kmer_alt)): print("Warning! For '"+rsid+"' different lengths detected for the reference (k="+str(len(kmer_ref))+") and the alternative (k="+str(len(kmer_alt))+") kmers !")
      
    ref_df = counts_df.loc[counts_df['kmer'].isin([kmer_ref, rc(kmer_ref)])].reset_index(drop = True)
    alt_df = counts_df.loc[counts_df['kmer'].isin([kmer_alt, rc(kmer_alt)])].reset_index(drop = True)
    
    if(ref_df.empty):
        ref_counts = np.nan
    else:
        ref_counts = int(ref_df.at[0, 'occurrence'])
    
    if(alt_df.empty):
        alt_counts = np.nan
    else:
        alt_counts = int(alt_df.at[0, 'occurrence'])

    return(ref_counts, alt_counts)


def main():
    """The main function"""
    counts_list_file, kiv_kmers_file, lpa_kmers_file, rsids_kmers_file, output_folder, plot_on, verbose_on = parse_arguments()
    check_arguments(counts_list_file, kiv_kmers_file, lpa_kmers_file, rsids_kmers_file, output_folder)

    os.makedirs(str(output_folder))
    if(plot_on): os.makedirs(str(output_folder)+"/plots/")

    # sample_dict will contain the sample ID as key and as value a list containing:
    # The KIV2 CN, and a dictionnary of rsids (rsid as key, and list of ref, alt counts as values)
    samples_dict = {}

    kiv_kmers_df = read_kmer_file(kiv_kmers_file)
    lpa_kmers_df = read_kmer_file(lpa_kmers_file)
    
    if(verbose_on): print("\nIdentified '"+str(kiv_kmers_df.shape[0])+"' KIV2 curated kmers")
    if(verbose_on): print("Identified '"+str(lpa_kmers_df.shape[0])+"' Normalisation curated kmers")
    
    # We check if the set of KIV2 kmers is disjoint from the LPA kmers:
    # if not, we set overlap to true and send a warning to the user.
    if(not(set(kiv_kmers_df['kmer']).isdisjoint(lpa_kmers_df['kmer']))):
        print("Warning ! There is some overlap between the KIV2 kmers and the Normalisation kmers, is this expected?\n")   
    
    # If the rsids file was provided we read the kmers:
    rsids_kmers_df = pd.DataFrame()
    if(rsids_kmers_file != None):
        rsids_kmers_df = read_rsids_file(rsids_kmers_file, verbose_on)
    
    # Calculating the CNs for all samples in the list of depth files:
    with open(counts_list_file, "r") as counts_handler:
        for counts_row in counts_handler:
            
            if(len(counts_row.split("\t")) != 2):
                sys.exit("Error: the file given to --counts contains '" + str(len(counts_row.split("\t"))) + "' columns. It should only contain two columns (tab-delimited), format: 'id    path/to/kmer_counts.tsv'")
            
            sample_id = counts_row.split("\t")[0].strip()
            counts_file = counts_row.split("\t")[1].strip()
            
            if(verbose_on): print("Processing '" + str(sample_id) + "'")
            # Using -1 as a default value (CNs should never be negative)
            CN = -1

            counts_df = read_counts(counts_file)
            # We add the "kiv", "lpa" and potentially the "rsid" labels to the corresponding kmers:
            counts_df.loc[:, 'source'] = "unknown"
            counts_df.loc[counts_df['kmer'].isin(kiv_kmers_df['kmer']), ['source']] = "kiv"
            counts_df.loc[counts_df['kmer'].isin(lpa_kmers_df['kmer']), ['source']] = "lpa"
            if not rsids_kmers_df.empty:
                counts_df.loc[counts_df['kmer'].isin(rsids_kmers_df['kmer_ref']), ['source']] = "snp_ref"
                counts_df.loc[counts_df['kmer'].isin(rsids_kmers_df['kmer_alt']), ['source']] = "snp_alt"
                # To take into account the reverse complements of the snp kmers:
                ref_rc = [rc(x) for x in rsids_kmers_df['kmer_ref']]
                alt_rc = [rc(x) for x in rsids_kmers_df['kmer_alt']]
                counts_df.loc[counts_df['kmer'].isin(ref_rc), ['source']] = "snp_ref"
                counts_df.loc[counts_df['kmer'].isin(alt_rc), ['source']] = "snp_alt"
            
            kiv_counts_df = counts_df.loc[counts_df['source'] == "kiv"]
            lpa_counts_df = counts_df.loc[counts_df['source'] == "lpa"]
            unknown_df = counts_df.loc[counts_df['source'] == "unknown"]
            
            if(verbose_on): print("\tKIV2 kmers with 0 counts: "+ str(kiv_counts_df.loc[kiv_counts_df['occurrence'] == 0].shape[0]) + " / " + str(kiv_counts_df.shape[0]))
            if(verbose_on): print("\tNormalisation kmers with 0 counts: "+ str(lpa_counts_df.loc[lpa_counts_df['occurrence'] == 0].shape[0]) + " / " + str(lpa_counts_df.shape[0]))
            if(verbose_on): print("\tUnknown kmers: "+ str(unknown_df.shape[0]))

            if(kiv_counts_df.shape[0] == 0 or lpa_counts_df.shape[0] == 0):
                sys.exit("Error, no Normalisation and/or KIV2 kmers found for sample '"+ str(sample_id) +"'")
                
            CN = get_kmer_CN(kiv_counts_df, lpa_counts_df, verbose_on)
            if(verbose_on): print("\tCN = %.2f\n" % CN)
            
            if(CN < 0): sys.exit("Error: CN is negative, something went wrong for sample '"+ sample_id +"'")
                
            # The keys of values dict will be the kiv2 CN, and the occurrences of the ref and alt kmers:
            values_dict = {}
            values_dict['KIV2_CN'] = CN
            
            # We add the kemrs to "values_dict" if they exist:
            if not rsids_kmers_df.empty:
                for index, row in rsids_kmers_df.iterrows():
                    # rsid as key, and value is a list of 2 values (the reference occurrences, and the alternative occurrences):
                    ref_occ, alt_occ = process_rsid(counts_df, row['rsid'], row['kmer_ref'], row['kmer_alt']) 
                    values_dict[row['rsid']+"_ref"] = ref_occ
                    values_dict[row['rsid']+"_alt"] = alt_occ
            
            samples_dict[sample_id] = values_dict
            
            if(plot_on):
                plot_filename = str(output_folder) + "/plots/" + str(sample_id) + "_cov.pdf"
                plot_occurrences(kiv_counts_df, lpa_counts_df, plot_filename, sample_id, CN)
                
    
    # For each sample, we have a dictionnary corresponding to the columns (as keys).
    # We tranform it into a DataFrame (and transpose it to have the samples as rows):
    samples_df = pd.DataFrame.from_dict(samples_dict).transpose()
    
    # If we have rsids counts to print, we transform them to int again:
    # We use Int64, in case they are NaN within the column (int does not support missing values):
    if not rsids_kmers_df.empty:
        for rsid in rsids_kmers_df['rsid']:
            samples_df[rsid+"_ref"] = samples_df[rsid+"_ref"].astype('Int64')
            samples_df[rsid+"_alt"] = samples_df[rsid+"_alt"].astype('Int64')
    
    # To add a column name to the samples
    samples_df.index.name = 'ID'
    samples_df.reset_index(inplace = True)
    
    # Adding deciles next to the count (better for comparisons between different studies / sequencing tech):
    # Trying to get unique bins, if not (eg: when there are few samples) we warn the user and drop the non-unique bins.
    try:
        samples_df['quantile'] = pd.qcut(samples_df['KIV2_CN'], 10, labels = False, duplicates = 'raise')
    except ValueError:
        print("Warning: quantiles bins are not unique, dropping non-unique bins.")
        samples_df['quantile'] = pd.qcut(samples_df['KIV2_CN'], 10, labels = False, duplicates = 'drop')

    # Writing the results to the output file:
    CNs_file = str(output_folder)+"/kilda_kiv2.CNs"
    if(verbose_on): print("Writing output to: "+CNs_file)
    samples_df.to_csv(CNs_file, sep = "\t", index = False, float_format = '%.2f', na_rep = "NA")

    if(verbose_on): print("Done!")


if __name__ == "__main__":
    main()
